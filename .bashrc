# ~/.bashrc: executed by bash(1) for non-login shells.
export TERM=xterm-256color
export TERMDARK=1

# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=9999
HISTFILESIZE=9999

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# Set prompt if ssh use orange-white, otherwise use magenta-black
if [ -n "$SSH_CLIENT" ]; then
    PS1='\[\e[1;34m\]\[\e[7;33m\]\$:\w >\[\e[m\] '
else
    PS1='\[\e[1;30m\]\$:\[\e[1;33m\]\w \[\e[1;30m\]\>\[\e[m\] '
fi
# Set title
PS1="\[\e]0;\h:\u \j \!\a\]$PS1"

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# I like aliases :)
if [ -f ~/.bash_aliases ]; then
    source ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

#enable adb autocompleter
if [ -e /bin/adb.txt ] ; then
    source /bin/adb.txt
fi

export VISUAL=nvim
export PROMPT_DIRTRIM=2

# I love fzf...
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -200'"
export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"
export FZF_CTRL_T_OPTS="--preview-window down:50% --preview '(coderay {} 2> /dev/null || cat {} || tree -C {}) 2> /dev/null | head -200'"

# fzf edit
fvim() {
  local files
  IFS=$'\n' files=($(fzf --preview-window down:70% --no-height --no-reverse --preview '(coderay {} 2> /dev/null || cat {} || tree -C {}) 2> /dev/null | head -200' --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# GIT heart FZF
# -------------

is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

gf() {
  is_in_git_repo || return
  git -c color.status=always status --short |
  fzf-down -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

gb() {
  is_in_git_repo || return
  git branch -a --color=always | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

gt() {
  is_in_git_repo || return
  git ls-files | fzf-down --multi --no-height --preview-window down:70% --preview '(coderay {} 2> /dev/null || cat {} || tree -C {}) 2> /dev/null | head -200'
}

gh() {
  is_in_git_repo || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
  fzf-down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
  grep -o "[a-f0-9]\{7,\}"
}

gr() {
  is_in_git_repo || return
  git remote -v | awk '{print $1 "\t" $2}' | uniq |
  fzf-down --tac \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {1} | head -200' |
  cut -d$'\t' -f1
}

# Save my ssh-key, fuck typing it so much :).
# Stole from Mr. Archer.
function sshkeys() {
    set -x
    AGENT_FILE=$HOME/.ssh-agent-`hostname`
    NUM_AGENTS_RUNNING=$(ps aux|grep ssh-agent|grep $USER|grep -v grep|wc -l)

    # There can be only one!
    # If there is more than one ssh-agent running, then kill them all and start a new one
    if [ $NUM_AGENTS_RUNNING -gt 1 ] ; then
        echo "WARNING: $NUM_AGENTS_RUNNING ssh-agent processes running.  \nKilling them all and starting a new one."      
        killall -9 ssh-agent 2>/dev/null
        rm -f $AGENT_FILE
    fi

    if [ ! -e $AGENT_FILE ] ; then
        ssh-agent -s > $AGENT_FILE
        ssh-add
    fi
    . $AGENT_FILE

    if ! kill -0 $SSH_AGENT_PID >/dev/null 2>&1 ; then
        echo "PID $SSH_AGENT_PID is not running on `hostname`.  restarting ssh-agent"
        ssh-agent -s > $AGENT_FILE
        . $AGENT_FILE
        ssh-add
    fi
    set +x
}
